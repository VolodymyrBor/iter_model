from collections.abc import AsyncIterable, AsyncIterator, Awaitable, Callable, Iterable
from typing import Generic, ParamSpec, TypeVar

from .async_utils import asyncify as asyncify
from .empty_iterator import EmptyAsyncIterator as EmptyAsyncIterator

_T = TypeVar('_T')
_R = TypeVar('_R')
_P = ParamSpec('_P')
_DefaultT = TypeVar('_DefaultT')
_KeyFunc = Callable[[_T], _R | Awaitable[_R]]
_BinaryFunc = Callable[[_T, _T], _R | Awaitable[_R]]
_ConditionFunc = Callable[[_T], bool | Awaitable[bool]]

def async_iter(func: Callable[_P, AsyncIterable[_T]]) -> Callable[_P, AsyncIter[_T]]: ...

class AsyncIter(Generic[_T]):
    _it: AsyncIterator[_T]

    def __init__(self, it: AsyncIterable[_T]) -> None: ...
    def __aiter__(self) -> AsyncIterator[_T]: ...
    async def __anext__(self) -> _T: ...

    @classmethod
    def from_sync(cls, it: Iterable[_T]) -> AsyncIter[_T]: ...
    @classmethod
    def empty(cls) -> AsyncIter[_T]: ...
    async def to_list(self) -> list[_T]: ...
    async def to_tuple(self) -> tuple[_T, ...]: ...
    async def to_set(self) -> set[_T]: ...
    def enumerate(self, start: int = ...) -> AsyncIter[tuple[int, _T]]: ...
    def take(self, limit: int) -> AsyncIter[_T]: ...
    def map(self, func: Callable[[_T], _R | Awaitable[_R]]) -> AsyncIter[_R]: ...
    def skip(self, count: int) -> AsyncIter[_T]: ...
    def skip_while(self, func: _ConditionFunc) -> AsyncIter[_T]: ...
    def skip_where(self, func: _ConditionFunc) -> AsyncIter: ...
    async def count(self) -> int: ...
    async def first_where(self, func: _ConditionFunc, default: _DefaultT = ...) -> _T | _DefaultT: ...
    async def last_where(self, func: _ConditionFunc, default: _DefaultT = ...) -> _T | _DefaultT: ...
    def where(self, func: _ConditionFunc) -> AsyncIter[_T]: ...
    def take_while(self, func: _ConditionFunc) -> AsyncIter[_T]: ...
    async def next(self) -> _T: ...
    async def last(self) -> _T: ...
    def chain(self, *iterables: AsyncIterator[_T]) -> AsyncIter[_T]: ...
    async def all(self) -> bool: ...
    async def any(self) -> bool: ...
    def mark_first(self) -> AsyncIter[tuple[_T, bool]]: ...
    def mark_last(self) -> AsyncIter[tuple[_T, bool]]: ...
    def mark_first_last(self) -> AsyncIter[tuple[_T, bool, bool]]: ...
    async def reduce(self, func: _BinaryFunc, initial: _T = ...) -> _T | _R: ...
    async def max(self, key: _KeyFunc | None = ..., default: _DefaultT = ...) -> _T | _DefaultT: ...
    async def min(self, key: _KeyFunc | None = ..., default: _DefaultT = ...) -> _T | _DefaultT: ...
    def accumulate(self, func: _BinaryFunc = ..., initial: _T | None = ...) -> AsyncIter[_R]: ...
    def append_left(self, item: _T) -> AsyncIter[_T]: ...
    def append_right(self, item: _T) -> AsyncIter[_T]: ...
    def append_at(self, index: int, item: _T) -> AsyncIter[_T]: ...
    def zip(self, *iterables: AsyncIterator[_T], strict: bool = ...) -> AsyncIter[list[_T]]: ...
    def zip_longest(self, *iterables: AsyncIterator[_T], fillvalue: _R = ...) -> AsyncIter[list[_T | _R]]: ...
    def islice(self, start: int = ..., stop: int | None = ..., step: int = ...) -> AsyncIter[_T]: ...
    async def item_at(self, index: int) -> _T: ...
    async def contains(self, item: _T) -> bool: ...
    async def is_empty(self) -> bool: ...
    def pairwise(self) -> AsyncIter[tuple[_T, _T]]: ...
    def batches(self, batch_size: int) -> AsyncIter[tuple[_T, ...]]: ...
    def flatten(self: AsyncIter[AsyncIterator[_T]]) -> AsyncIter[_T]: ...

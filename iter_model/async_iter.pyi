from .async_utils import asyncify as asyncify
from .empty_iterator import EmptyAsyncIterator as EmptyAsyncIterator
from typing import AsyncIterable, AsyncIterator, Awaitable, Callable, Generic, Iterable, ParamSpec, TypeVar, overload

T = TypeVar('T')
R = TypeVar('R')
P = ParamSpec('P')
DefaultT = TypeVar('DefaultT')
KeyFunc = Callable[[T], R | Awaitable[R]]
BinaryFunc = Callable[[T, T], R | Awaitable[R]]
ConditionFunc = Callable[[T], bool | Awaitable[bool]]

def async_iter(func: Callable[P, AsyncIterable[T]]) -> Callable[P, AsyncIter[T]]: ...

class AsyncIter(Generic[T]):
    _it: AsyncIterator[T]

    def __init__(self, it: AsyncIterable[T]) -> None: ...
    def __aiter__(self) -> AsyncIterator[T]: ...
    def __anext__(self) -> Awaitable[T]: ...
    @classmethod
    def from_sync(cls, it: Iterable[T]) -> AsyncIter[T]: ...
    @classmethod
    def empty(cls) -> AsyncIter[T]: ...
    async def to_list(self) -> list[T]: ...
    async def to_tuple(self) -> tuple[T, ...]: ...
    async def to_set(self) -> set[T]: ...
    def enumerate(self, start: int = ...) -> AsyncIter[tuple[int, T]]: ...
    def take(self, limit: int) -> AsyncIter[T]: ...
    def map(self, func: Callable[[T], R | Awaitable[R]]) -> AsyncIter[R]: ...
    def skip(self, count: int) -> AsyncIter[T]: ...
    def skip_while(self, func: ConditionFunc) -> AsyncIter[T]: ...
    def skip_where(self, func: ConditionFunc) -> AsyncIter: ...
    async def count(self) -> int: ...
    async def first_where(self, func: ConditionFunc, default: DefaultT = ...) -> T | DefaultT: ...
    async def last_where(self, func: ConditionFunc, default: DefaultT = ...) -> T | DefaultT: ...
    def where(self, func: ConditionFunc) -> AsyncIter[T]: ...
    def take_while(self, func: ConditionFunc) -> AsyncIter[T]: ...
    async def next(self) -> T: ...
    async def last(self) -> T: ...
    def chain(self, *iterables: AsyncIterator[T]) -> AsyncIter[T]: ...
    async def all(self) -> bool: ...
    async def any(self) -> bool: ...
    async def first(self) -> T: ...
    def mark_first(self) -> AsyncIter[tuple[T, bool]]: ...
    def mark_last(self) -> AsyncIter[tuple[T, bool]]: ...
    def mark_first_last(self) -> AsyncIter[tuple[T, bool, bool]]: ...
    async def reduce(self, func: BinaryFunc, initial: T = ...) -> T | R: ...
    async def max(self, key: KeyFunc | None = ..., default: DefaultT = ...) -> T | DefaultT: ...
    async def min(self, key: KeyFunc | None = ..., default: DefaultT = ...) -> T | DefaultT: ...
    def accumulate(self, func: BinaryFunc = ..., initial: T | None = ...) -> AsyncIter[R]: ...
    def append_left(self, item: T) -> AsyncIter[T]: ...
    def append_right(self, item: T) -> AsyncIter[T]: ...
    def append_at(self, index: int, item: T) -> AsyncIter[T]: ...
    def zip(self, *iterables: AsyncIterator[T], strict: bool = ...) -> AsyncIter[list[T]]: ...
    def zip_longest(self, *iterables: AsyncIterator[T], fillvalue: R = ...) -> AsyncIter[list[T | R]]: ...
    def get_slice(self, start: int = ..., stop: int | None = ..., step: int = ...) -> AsyncIter[T]: ...
    async def item_at(self, index: int) -> T: ...
    async def contains(self, item: T) -> bool: ...
    async def is_empty(self) -> bool: ...
    async def is_not_empty(self) -> bool: ...
    def pairwise(self) -> AsyncIter[tuple[T, T]]: ...
    async def get_len(self) -> int: ...
    def batches(self, batch_size: int) -> AsyncIter[tuple[T, ...]]: ...
    def flatten(self: AsyncIter[AsyncIterator[T]]) -> AsyncIter[T]: ...
    @overload
    def __getitem__(self, index: int) -> Awaitable[T]: ...
    @overload
    def __getitem__(self, index: slice) -> AsyncIter[T]: ...

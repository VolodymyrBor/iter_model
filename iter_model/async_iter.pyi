from .async_utils import asyncify as asyncify
from .empty_iterator import EmptyAsyncIterator as EmptyAsyncIterator
from _typeshed import Incomplete
from typing import AsyncIterable, AsyncIterator, Awaitable, Callable, Generic, Iterable, ParamSpec, TypeVar

T = TypeVar('T')
R = TypeVar('R')
P = ParamSpec('P')
DefaultT = TypeVar('DefaultT')
KeyFunc: Incomplete
BinaryFunc: Incomplete
ConditionFunc: Incomplete

def async_iter(func: Callable[P, AsyncIterable[T]]) -> Callable[P, 'AsyncIter[T]']: ...

class AsyncIter(Generic[T]):
    def __init__(self, it: AsyncIterable[T]) -> None: ...
    def __aiter__(self) -> AsyncIterator[T]: ...
    def __anext__(self) -> Awaitable[T]: ...
    @classmethod
    async def from_sync(cls, it: Iterable[T]) -> AsyncIter[T]: ...
    @classmethod
    def empty(cls) -> AsyncIter[T]: ...
    async def to_list(self) -> list[T]: ...
    async def to_tuple(self) -> tuple[T, ...]: ...
    async def to_set(self) -> set[T]: ...
    async def enumerate(self, start: int = ...) -> AsyncIter[tuple[int, T]]: ...
    async def take(self, limit: int) -> AsyncIter[T]: ...
    async def map(self, func: Callable[[T], R | Awaitable[R]]) -> AsyncIter[R]: ...
    async def skip(self, count: int) -> AsyncIter[T]: ...
    async def skip_while(self, func: ConditionFunc) -> AsyncIter[T]: ...
    async def skip_where(self, func: ConditionFunc) -> AsyncIter: ...
    async def count(self) -> int: ...
    async def first_where(self, func: ConditionFunc, default: DefaultT = ...) -> T | DefaultT: ...
    async def last_where(self, func: ConditionFunc, default: DefaultT = ...) -> T | DefaultT: ...
    async def where(self, func: ConditionFunc) -> AsyncIter[T]: ...
    async def take_while(self, func: ConditionFunc) -> AsyncIter[T]: ...
    async def next(self) -> T: ...
    async def last(self) -> T: ...
    async def chain(self, *iterables: AsyncIterable[T]) -> AsyncIter[T]: ...
    async def all(self) -> bool: ...
    async def any(self) -> bool: ...
    async def first(self) -> T: ...
    async def mark_first(self) -> AsyncIter[tuple[T, bool]]: ...
    async def mark_last(self) -> AsyncIter[tuple[T, bool]]: ...
    async def mark_first_last(self) -> AsyncIter[tuple[T, bool, bool]]: ...
    async def reduce(self, func: BinaryFunc, initial: T = ...) -> T | R: ...
    async def max(self, key: KeyFunc | None = ..., default: DefaultT = ...) -> T | DefaultT: ...
    async def min(self, key: KeyFunc | None = ..., default: DefaultT = ...) -> T | DefaultT: ...
    async def accumulate(self, func: BinaryFunc = ..., initial: T | None = ...) -> AsyncIter[R]: ...
    async def append_left(self, item: T) -> AsyncIter[T]: ...
    async def append_right(self, item: T) -> AsyncIter[T]: ...
    async def append_at(self, index: int, item: T) -> AsyncIter[T]: ...
    async def zip(self, *iterables: AsyncIterable[T], strict: bool = ...) -> AsyncIter[list[T]]: ...
    async def zip_longest(self, *iterables: AsyncIterable[T], fillvalue: R = ...) -> AsyncIter[list[T | R]]: ...
    async def get_slice(self, start: int = ..., stop: int | None = ..., step: int = ...) -> AsyncIter[T]: ...
    async def item_at(self, index: int) -> T: ...
    async def contains(self, item: T) -> bool: ...
    async def is_empty(self) -> bool: ...
    async def is_not_empty(self) -> bool: ...
    async def pairwise(self) -> AsyncIter[tuple[T, T]]: ...
    async def get_len(self) -> int: ...
    async def batches(self, batch_size: int) -> AsyncIter[tuple[T, ...]]: ...
    async def flatten(self) -> AsyncIterable[T]: ...
    def __getitem__(self, index: int | slice) -> Awaitable[T] | AsyncIter[T]: ...
